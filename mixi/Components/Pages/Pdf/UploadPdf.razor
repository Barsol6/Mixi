@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using mixi.Modules.Database
@using mixi.Modules.Pdf
@using mixi.Modules.UI

@rendermode InteractiveServer

@inject IPdfRepository PdfRepository
@inject PdfPopup PdfPopup
@inject ProtectedSessionStorage Storage

@implements IDisposable

    <div class="pdfChoicePanel">
        <h3>Send Character Sheet</h3>
        <div class="login-box items-center">
            <div class="login">
                <div class="data-box">
                    <InputFile OnChange="@(e => HandleFileSelected(e))" accept=".pdf" />
                </div>
                <div class="data-box">
                    <input @bind="_fileName" type="text" required/>
                    <span>PDF Name</span>
                </div>
                @if (_isUploading)
                {
                    <p>Uploading...</p>
                }
                @if (!string.IsNullOrEmpty(_errorMessage))
                {
                    <p>@_errorMessage</p>
                }
                <div class="data-box">
                    <div class="logButton" @onclick="@(async () => { if (_fileSelected && !_isUploading && _fileName!=String.Empty) await UploadFile(); })" style="@(_fileSelected && !_isUploading ? "" : "opacity: 0.5; cursor: not-allowed;")">
                        <span class="logButton-content">SEND</span>
                    </div>
                </div>
                <div class="data-box">
                    <div class="logButton">
                        <div class="closeButton-content " @onclick="() => ClosePopup()">
                            CLOSE
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>
@code {
    
    private IBrowserFile _selectedFile;
    private bool _fileSelected = false;
    private bool _isUploading = false;
    private string _errorMessage = String.Empty;
    private string _fileName = String.Empty;
    
    protected override void OnInitialized()
    {
        this.PdfPopup.PdfNameChanged += () => InvokeAsync(StateHasChanged);
        this.PdfPopup.IsVisibleChange += () => InvokeAsync(StateHasChanged);
        base.OnInitialized();
    }
    
    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        _selectedFile = e.File;
        _fileSelected = true;
        _errorMessage = string.Empty;
        Console.WriteLine($"File selected: {_fileSelected}, ContentType: {_selectedFile.ContentType}");
        if (!_selectedFile.ContentType.Equals("application/pdf",StringComparison.OrdinalIgnoreCase))
        {
            _errorMessage = "File must be PDF";
            _fileSelected = false;
        }
        StateHasChanged();
    }

    private async Task UploadFile()
    {
        if (!_fileSelected || _isUploading)
        {
            return;
        }

        try
        {
            _isUploading = true;
            _errorMessage = String.Empty;

            using var memoryStream = new MemoryStream();
            await _selectedFile.OpenReadStream(maxAllowedSize: 20 * 1024 * 1024).CopyToAsync(memoryStream);

            var document = new PdfDocument
            {
                Name = _fileName,
                FormData = "{}",
                Content = memoryStream.ToArray()
            };

            var id = await PdfRepository.SaveAsync(document, memoryStream.ToArray());
            PdfPopup.PdfName = id;
        }
        catch (Exception e)
        {
            _errorMessage = $"Uploading Error: {e.Message}";
        }
        finally
        {
            _isUploading = false;
            StateHasChanged();
        }
    }
    private async void ClosePopup()
    {
        PdfPopup.IsVisible = false;
        await Storage.SetAsync("PdfPopupIsVisible", false);
    }
    
    public void Dispose()
    {
        this.PdfPopup.IsVisibleChange -= StateHasChanged;
        this.PdfPopup.PdfNameChanged -= StateHasChanged;
    }

}